From 2f11300506221238f3e501c59139e977331a5993 Mon Sep 17 00:00:00 2001
From: belijzajac <tautvydas749@gmail.com>
Date: Tue, 7 Mar 2023 19:40:53 +0200
Subject: [PATCH] Hook up C tests

---
 src/Makefile          |  12 +-
 src/test_c_kzg_4844.c | 461 +++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 466 insertions(+), 7 deletions(-)

diff --git a/src/Makefile b/src/Makefile
index 1a21407..b383c0c 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -10,14 +10,14 @@ FIELD_ELEMENTS_PER_BLOB ?= 4096
 
 # The base compiler flags. More can be added on command line.
 CFLAGS += -I../inc
-CFLAGS += -Wall -Wextra -Werror -O2
+CFLAGS += -Wextra -Werror -O2
 CFLAGS += -DFIELD_ELEMENTS_PER_BLOB=$(FIELD_ELEMENTS_PER_BLOB)
 
 # Disable optimizations. Put after $CFLAGS.
 NO_OPTIMIZE = -O0
 
 # Compiler flags for including blst. Put after source files.
-BLST = -L../lib -lblst
+RUST_KZG_LIB = -L../../../../target/release -lmcl_rust -lm -lstdc++
 
 # Compiler flags for generating coverage data.
 COVERAGE = -fprofile-instr-generate -fcoverage-mapping
@@ -47,14 +47,14 @@ all: c_kzg_4844.o test
 %.o: %.c
 	@$(CC) $(CFLAGS) -c $<
 
-test_c_kzg_4844: test_c_kzg_4844.c c_kzg_4844.c
-	@$(CC) $(CFLAGS) $(NO_OPTIMIZE) -o $@ $< $(BLST)
+test_c_kzg_4844: test_c_kzg_4844.c
+	@$(CC) $(CFLAGS) $(NO_OPTIMIZE) -o $@ $< $(RUST_KZG_LIB)
 
 test_c_kzg_4844_cov: test_c_kzg_4844.c c_kzg_4844.c
-	@$(CC) $(CFLAGS) $(NO_OPTIMIZE) $(COVERAGE) -o $@ $< $(BLST)
+	@$(CC) $(CFLAGS) $(NO_OPTIMIZE) $(COVERAGE) -o $@ $<
 
 test_c_kzg_4844_prof: test_c_kzg_4844.c c_kzg_4844.c
-	@$(CC) $(CFLAGS) $(NO_OPTIMIZE) $(PROFILE) -o $@ $< $(BLST) $(PROFILER)
+	@$(CC) $(CFLAGS) $(NO_OPTIMIZE) $(PROFILE) -o $@ $< $(PROFILER)
 
 .PHONY: blst
 blst:
diff --git a/src/test_c_kzg_4844.c b/src/test_c_kzg_4844.c
index 29e681d..25b6936 100644
--- a/src/test_c_kzg_4844.c
+++ b/src/test_c_kzg_4844.c
@@ -1,7 +1,7 @@
 /*
  * This file contains unit tests for C-KZG-4844.
  */
-#include "c_kzg_4844.c"
+#include "c_kzg_4844.h"
 #include "tinytest.h"
 
 #include <assert.h>
@@ -22,6 +22,465 @@ KZGSettings s;
 // Helper functions
 ///////////////////////////////////////////////////////////////////////////////
 
+// forward declare
+C_KZG_RET bytes_to_bls_field(fr_t *out, const Bytes32 *b);
+C_KZG_RET evaluate_polynomial_in_evaluation_form(fr_t *out, const Polynomial *p, const fr_t *x, const KZGSettings *s);
+C_KZG_RET blob_to_polynomial(Polynomial *p, const Blob *blob);
+
+// copied from c_kzg_4844.c
+static C_KZG_RET validate_kzg_g1(g1_t *out, const Bytes48 *b) {
+    /* Convert the bytes to a p1 point */
+    blst_p1_affine p1_affine;
+    /* The uncompress routine also checks that the point is on the curve */
+    if (blst_p1_uncompress(&p1_affine, b->bytes) != BLST_SUCCESS)
+        return C_KZG_BADARGS;
+    blst_p1_from_affine(out, &p1_affine);
+
+    /* The point at infinity is accepted! */
+    if (blst_p1_is_inf(out)) return C_KZG_OK;
+    /* The point must be on the right subgroup */
+    if (!blst_p1_in_g1(out)) return C_KZG_BADARGS;
+
+    return C_KZG_OK;
+}
+
+// copied from c_kzg_4844.c
+static void hash_to_bls_field(fr_t *out, const Bytes32 *b) {
+    blst_scalar tmp;
+    blst_scalar_from_lendian(&tmp, b->bytes);
+    blst_fr_from_scalar(out, &tmp);
+}
+
+// copied from c_kzg_4844.c
+static void bytes_from_bls_field(Bytes32 *out, const fr_t *in) {
+    blst_scalar_from_fr((blst_scalar *)out->bytes, in);
+}
+
+// copied from c_kzg_4844.c
+static void bytes_from_g1(Bytes48 *out, const g1_t *in) {
+    blst_p1_compress(out->bytes, in);
+}
+
+// copied from c_kzg_4844.c
+static C_KZG_RET bytes_to_kzg_commitment(g1_t *out, const Bytes48 *b) {
+    return validate_kzg_g1(out, b);
+}
+
+// copied from c_kzg_4844.c
+#define CHECK(cond) \
+    if (!(cond)) return C_KZG_BADARGS
+
+// copied from c_kzg_4844.c
+#define rev_4byte(a) \
+    (rev_byte(a) << 24 | rev_byte((a) >> 8) << 16 | rev_byte((a) >> 16) << 8 | \
+     rev_byte((a) >> 24) << 0)
+
+// copied from c_kzg_4844.c
+#define rev_byte(a) ((((a)&0xff) * 0x0202020202ULL & 0x010884422010ULL) % 1023)
+
+// copied from c_kzg_4844.c
+static uint32_t reverse_bits(uint32_t a) {
+    return rev_4byte(a);
+}
+
+// copied from c_kzg_4844.c
+static const g1_t G1_IDENTITY = {
+    {0L, 0L, 0L, 0L, 0L, 0L},
+    {0L, 0L, 0L, 0L, 0L, 0L},
+    {0L, 0L, 0L, 0L, 0L, 0L}};
+
+// copied from c_kzg_4844.c
+static const g1_t G1_GENERATOR = {
+    {0x5cb38790fd530c16L, 0x7817fc679976fff5L, 0x154f95c7143ba1c1L,
+     0xf0ae6acdf3d0e747L, 0xedce6ecc21dbf440L, 0x120177419e0bfb75L},
+    {0xbaac93d50ce72271L, 0x8c22631a7918fd8eL, 0xdd595f13570725ceL,
+     0x51ac582950405194L, 0x0e1c8c3fad0059c0L, 0x0bbc3efc5008a26aL},
+    {0x760900000002fffdL, 0xebf4000bc40c0002L, 0x5f48985753c758baL,
+     0x77ce585370525745L, 0x5c071a97a256ec6dL, 0x15f65ec3fa80e493L}};
+
+// copied from c_kzg_4844.c
+static const uint64_t SCALE2_ROOT_OF_UNITY[][4] = {
+    {0x0000000000000001L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L},
+    {0xffffffff00000000L, 0x53bda402fffe5bfeL, 0x3339d80809a1d805L, 0x73eda753299d7d48L},
+    {0x0001000000000000L, 0xec03000276030000L, 0x8d51ccce760304d0L, 0x0000000000000000L},
+    {0x7228fd3397743f7aL, 0xb38b21c28713b700L, 0x8c0625cd70d77ce2L, 0x345766f603fa66e7L},
+    {0x53ea61d87742bcceL, 0x17beb312f20b6f76L, 0xdd1c0af834cec32cL, 0x20b1ce9140267af9L},
+    {0x360c60997369df4eL, 0xbf6e88fb4c38fb8aL, 0xb4bcd40e22f55448L, 0x50e0903a157988baL},
+    {0x8140d032f0a9ee53L, 0x2d967f4be2f95155L, 0x14a1e27164d8fdbdL, 0x45af6345ec055e4dL},
+    {0x5130c2c1660125beL, 0x98d0caac87f5713cL, 0xb7c68b4d7fdd60d0L, 0x6898111413588742L},
+    {0x4935bd2f817f694bL, 0x0a0865a899e8deffL, 0x6b368121ac0cf4adL, 0x4f9b4098e2e9f12eL},
+    {0x4541b8ff2ee0434eL, 0xd697168a3a6000feL, 0x39feec240d80689fL, 0x095166525526a654L},
+    {0x3c28d666a5c2d854L, 0xea437f9626fc085eL, 0x8f4de02c0f776af3L, 0x325db5c3debf77a1L},
+    {0x4a838b5d59cd79e5L, 0x55ea6811be9c622dL, 0x09f1ca610a08f166L, 0x6d031f1b5c49c834L},
+    {0xe206da11a5d36306L, 0x0ad1347b378fbf96L, 0xfc3e8acfe0f8245fL, 0x564c0a11a0f704f4L},
+    {0x6fdd00bfc78c8967L, 0x146b58bc434906acL, 0x2ccddea2972e89edL, 0x485d512737b1da3dL},
+    {0x034d2ff22a5ad9e1L, 0xae4622f6a9152435L, 0xdc86b01c0d477fa6L, 0x56624634b500a166L},
+    {0xfbd047e11279bb6eL, 0xc8d5f51db3f32699L, 0x483405417a0cbe39L, 0x3291357ee558b50dL},
+    {0xd7118f85cd96b8adL, 0x67a665ae1fcadc91L, 0x88f39a78f1aeb578L, 0x2155379d12180caaL},
+    {0x08692405f3b70f10L, 0xcd7f2bd6d0711b7dL, 0x473a2eef772c33d6L, 0x224262332d8acbf4L},
+    {0x6f421a7d8ef674fbL, 0xbb97a3bf30ce40fdL, 0x652f717ae1c34bb0L, 0x2d3056a530794f01L},
+    {0x194e8c62ecb38d9dL, 0xad8e16e84419c750L, 0xdf625e80d0adef90L, 0x520e587a724a6955L},
+    {0xfece7e0e39898d4bL, 0x2f69e02d265e09d9L, 0xa57a6e07cb98de4aL, 0x03e1c54bcb947035L},
+    {0xcd3979122d3ea03aL, 0x46b3105f04db5844L, 0xc70d0874b0691d4eL, 0x47c8b5817018af4fL},
+    {0xc6e7a6ffb08e3363L, 0xe08fec7c86389beeL, 0xf2d38f10fbb8d1bbL, 0x0abe6a5e5abcaa32L},
+    {0x5616c57de0ec9eaeL, 0xc631ffb2585a72dbL, 0x5121af06a3b51e3cL, 0x73560252aa0655b2L},
+    {0x92cf4deb77bd779cL, 0x72cf6a8029b7d7bcL, 0x6e0bcd91ee762730L, 0x291cf6d68823e687L},
+    {0xce32ef844e11a51eL, 0xc0ba12bb3da64ca5L, 0x0454dc1edc61a1a3L, 0x019fe632fd328739L},
+    {0x531a11a0d2d75182L, 0x02c8118402867ddcL, 0x116168bffbedc11dL, 0x0a0a77a3b1980c0dL},
+    {0xe2d0a7869f0319edL, 0xb94f1101b1d7a628L, 0xece8ea224f31d25dL, 0x23397a9300f8f98bL},
+    {0xd7b688830a4f2089L, 0x6558e9e3f6ac7b41L, 0x99e276b571905a7dL, 0x52dd465e2f094256L},
+    {0x474650359d8e211bL, 0x84d37b826214abc6L, 0x8da40c1ef2bb4598L, 0x0c83ea7744bf1beeL},
+    {0x694341f608c9dd56L, 0xed3a181fabb30adcL, 0x1339a815da8b398fL, 0x2c6d4e4511657e1eL},
+    {0x63e7cb4906ffc93fL, 0xf070bb00e28a193dL, 0xad1715b02e5713b5L, 0x4b5371495990693fL}};
+
+// copied from c_kzg_4844.c
+static const fr_t FR_ZERO = {0L, 0L, 0L, 0L};
+
+// copied from c_kzg_4844.c
+static const fr_t FR_ONE = {
+    0x00000001fffffffeL, 0x5884b7fa00034802L,
+    0x998c4fefecbc4ff5L, 0x1824b159acc5056fL};
+
+// copied from c_kzg_4844.c
+static void compute_powers(fr_t *out, fr_t *x, uint64_t n) {
+    fr_t current_power = FR_ONE;
+    for (uint64_t i = 0; i < n; i++) {
+        out[i] = current_power;
+        blst_fr_mul(&current_power, &current_power, x);
+    }
+}
+
+// copied from c_kzg_4844.c
+static int log_2_byte(byte b) {
+    if (b < 2) return 0;
+    if (b < 4) return 1;
+    if (b < 8) return 2;
+    if (b < 16) return 3;
+    if (b < 32) return 4;
+    if (b < 64) return 5;
+    if (b < 128) return 6;
+    return 7;
+}
+
+// copied from c_kzg_4844.c
+static bool fr_is_one(const fr_t *p) {
+    uint64_t a[4];
+    blst_uint64_from_fr(a, p);
+    return a[0] == 1 && a[1] == 0 && a[2] == 0 && a[3] == 0;
+}
+
+// copied from c_kzg_4844.c
+static bool fr_equal(const fr_t *aa, const fr_t *bb) {
+    uint64_t a[4], b[4];
+    blst_uint64_from_fr(a, aa);
+    blst_uint64_from_fr(b, bb);
+    return a[0] == b[0] && a[1] == b[1] && a[2] == b[2] && a[3] == b[3];
+}
+
+// copied from c_kzg_4844.c
+static void fr_div(fr_t *out, const fr_t *a, const fr_t *b) {
+    blst_fr tmp;
+    blst_fr_eucl_inverse(&tmp, b);
+    blst_fr_mul(out, a, &tmp);
+}
+
+// copied from c_kzg_4844.c
+static void fr_pow(fr_t *out, const fr_t *a, uint64_t n) {
+    fr_t tmp = *a;
+    *out = FR_ONE;
+
+    while (true) {
+        if (n & 1) {
+            blst_fr_mul(out, out, &tmp);
+        }
+        if ((n >>= 1) == 0) break;
+        blst_fr_sqr(&tmp, &tmp);
+    }
+}
+
+// copied from c_kzg_4844.c
+static void fr_from_uint64(fr_t *out, uint64_t n) {
+    uint64_t vals[] = {n, 0, 0, 0};
+    blst_fr_from_uint64(out, vals);
+}
+
+// copied from c_kzg_4844.c
+static C_KZG_RET c_kzg_malloc(void **out, size_t size) {
+    *out = NULL;
+    if (size == 0) return C_KZG_BADARGS;
+    *out = malloc(size);
+    return *out != NULL ? C_KZG_OK : C_KZG_MALLOC;
+}
+
+// copied from c_kzg_4844.c
+static C_KZG_RET c_kzg_calloc(void **out, size_t count, size_t size) {
+    *out = NULL;
+    if (count == 0 || size == 0) return C_KZG_BADARGS;
+    *out = calloc(count, size);
+    return *out != NULL ? C_KZG_OK : C_KZG_MALLOC;
+}
+
+// copied from c_kzg_4844.c
+static C_KZG_RET new_fr_array(fr_t **x, size_t n) {
+    return c_kzg_calloc((void **)x, n, sizeof(fr_t));
+}
+
+// copied from c_kzg_4844.c
+static C_KZG_RET fr_batch_inv(fr_t *out, const fr_t *a, size_t len) {
+    C_KZG_RET ret;
+    fr_t *prod = NULL;
+    fr_t inv;
+    size_t i;
+
+    ret = new_fr_array(&prod, len);
+    if (ret != C_KZG_OK) goto out;
+
+    prod[0] = a[0];
+
+    for (i = 1; i < len; i++) {
+        blst_fr_mul(&prod[i], &a[i], &prod[i - 1]);
+    }
+
+    blst_fr_eucl_inverse(&inv, &prod[len - 1]);
+
+    for (i = len - 1; i > 0; i--) {
+        blst_fr_mul(&out[i], &inv, &prod[i - 1]);
+        blst_fr_mul(&inv, &a[i], &inv);
+    }
+    out[0] = inv;
+
+    out:
+    free(prod);
+    return ret;
+}
+
+// copied from c_kzg_4844.c
+static void g1_mul(g1_t *out, const g1_t *a, const fr_t *b) {
+    blst_scalar s;
+    blst_scalar_from_fr(&s, b);
+
+    // Count the number of bytes to be multiplied.
+    int i = sizeof(blst_scalar);
+    while (i && !s.b[i - 1])
+        --i;
+    if (i == 0) {
+        *out = G1_IDENTITY;
+    } else if (i == 1 && s.b[0] == 1) {
+        *out = *a;
+    } else {
+        // Count the number of bits to be multiplied.
+        blst_p1_mult(out, a, s.b, 8 * i - 7 + log_2_byte(s.b[i - 1]));
+    }
+}
+
+// copied from c_kzg_4844.c
+static void g1_sub(g1_t *out, const g1_t *a, const g1_t *b) {
+    g1_t bneg = *b;
+    blst_p1_cneg(&bneg, true);
+    blst_p1_add_or_double(out, a, &bneg);
+}
+
+// copied from c_kzg_4844.c
+static void g2_mul(g2_t *out, const g2_t *a, const fr_t *b) {
+    blst_scalar s;
+    blst_scalar_from_fr(&s, b);
+    blst_p2_mult(out, a, s.b, 8 * sizeof(blst_scalar));
+}
+
+// copied from c_kzg_4844.c
+static bool is_power_of_two(uint64_t n) {
+    return (n & (n - 1)) == 0;
+}
+
+// copied from c_kzg_4844.c
+static int log2_pow2(uint32_t n) {
+    const uint32_t b[] = {
+        0xAAAAAAAA, 0xCCCCCCCC, 0xF0F0F0F0, 0xFF00FF00, 0xFFFF0000};
+    register uint32_t r;
+    r = (n & b[0]) != 0;
+    r |= ((n & b[1]) != 0) << 1;
+    r |= ((n & b[2]) != 0) << 2;
+    r |= ((n & b[3]) != 0) << 3;
+    r |= ((n & b[4]) != 0) << 4;
+    return r;
+}
+
+// copied from c_kzg_4844.c
+static bool pairings_verify(
+    const g1_t *a1, const g2_t *a2, const g1_t *b1, const g2_t *b2
+) {
+    blst_fp12 loop0, loop1, gt_point;
+    blst_p1_affine aa1, bb1;
+    blst_p2_affine aa2, bb2;
+
+    // As an optimisation, we want to invert one of the pairings,
+    // so we negate one of the points.
+    g1_t a1neg = *a1;
+    blst_p1_cneg(&a1neg, true);
+
+    blst_p1_to_affine(&aa1, &a1neg);
+    blst_p1_to_affine(&bb1, b1);
+    blst_p2_to_affine(&aa2, a2);
+    blst_p2_to_affine(&bb2, b2);
+
+    blst_miller_loop(&loop0, &aa2, &aa1);
+    blst_miller_loop(&loop1, &bb2, &bb1);
+
+    blst_fp12_mul(&gt_point, &loop0, &loop1);
+    blst_final_exp(&gt_point, &gt_point);
+
+    return blst_fp12_is_one(&gt_point);
+}
+
+// copied from c_kzg_4844.c
+static C_KZG_RET bit_reversal_permutation(
+    void *values, size_t size, uint64_t n
+) {
+    CHECK(n >> 32 == 0);
+    CHECK(is_power_of_two(n));
+    CHECK(log2_pow2(n) != 0);
+
+    // Pointer arithmetic on `void *` is naughty, so cast to something
+    // definite
+    byte *v = values;
+    byte tmp[size];
+    int unused_bit_len = 32 - log2_pow2(n);
+    for (uint32_t i = 0; i < n; i++) {
+        uint32_t r = reverse_bits(i) >> unused_bit_len;
+        if (r > i) {
+            // Swap the two elements
+            memcpy(tmp, v + (i * size), size);
+            memcpy(v + (i * size), v + (r * size), size);
+            memcpy(v + (r * size), tmp, size);
+        }
+    }
+
+    return C_KZG_OK;
+}
+
+// copied from c_kzg_4844.c
+static void g1_lincomb_naive(
+    g1_t *out, const g1_t *p, const fr_t *coeffs, uint64_t len
+) {
+    g1_t tmp;
+    *out = G1_IDENTITY;
+    for (uint64_t i = 0; i < len; i++) {
+        g1_mul(&tmp, &p[i], &coeffs[i]);
+        blst_p1_add_or_double(out, out, &tmp);
+    }
+}
+
+// copied from c_kzg_4844.c
+static C_KZG_RET g1_lincomb_fast(
+    g1_t *out, const g1_t *p, const fr_t *coeffs, uint64_t len
+) {
+    C_KZG_RET ret;
+    void *scratch = NULL;
+    blst_p1_affine *p_affine = NULL;
+    blst_scalar *scalars = NULL;
+
+    // Tunable parameter: must be at least 2 since Blst fails for 0 or 1
+    if (len < 8) {
+        g1_lincomb_naive(out, p, coeffs, len);
+    } else {
+        // Blst's implementation of the Pippenger method
+        size_t scratch_size = blst_p1s_mult_pippenger_scratch_sizeof(len);
+        ret = c_kzg_malloc(&scratch, scratch_size);
+        if (ret != C_KZG_OK) goto out;
+        ret = c_kzg_calloc((void **)&p_affine, len, sizeof(blst_p1_affine));
+        if (ret != C_KZG_OK) goto out;
+        ret = c_kzg_calloc((void **)&scalars, len, sizeof(blst_scalar));
+        if (ret != C_KZG_OK) goto out;
+
+        // Transform the points to affine representation
+        const blst_p1 *p_arg[2] = {p, NULL};
+        blst_p1s_to_affine(p_affine, p_arg, len);
+
+        // Transform the field elements to 256-bit scalars
+        for (uint64_t i = 0; i < len; i++) {
+            blst_scalar_from_fr(&scalars[i], &coeffs[i]);
+        }
+
+        // Call the Pippenger implementation
+        const byte *scalars_arg[2] = {(byte *)scalars, NULL};
+        const blst_p1_affine *points_arg[2] = {p_affine, NULL};
+        blst_p1s_mult_pippenger(
+            out, points_arg, len, scalars_arg, 255, scratch
+        );
+    }
+
+    ret = C_KZG_OK;
+
+    out:
+    free(scratch);
+    free(p_affine);
+    free(scalars);
+    return ret;
+}
+
+// copied from c_kzg_4844.c
+static void fft_g1_fast(
+    g1_t *out,
+    const g1_t *in,
+    uint64_t stride,
+    const fr_t *roots,
+    uint64_t roots_stride,
+    uint64_t n
+) {
+    uint64_t half = n / 2;
+    if (half > 0) { // Tunable parameter
+        fft_g1_fast(out, in, stride * 2, roots, roots_stride * 2, half);
+        fft_g1_fast(
+            out + half, in + stride, stride * 2, roots, roots_stride * 2, half
+        );
+        for (uint64_t i = 0; i < half; i++) {
+            g1_t y_times_root;
+            g1_mul(&y_times_root, &out[i + half], &roots[i * roots_stride]);
+            g1_sub(&out[i + half], &out[i], &y_times_root);
+            blst_p1_add_or_double(&out[i], &out[i], &y_times_root);
+        }
+    } else {
+        *out = *in;
+    }
+}
+
+// copied from c_kzg_4844.c
+static C_KZG_RET fft_g1(
+    g1_t *out, const g1_t *in, bool inverse, uint64_t n, const FFTSettings *fs
+) {
+    uint64_t stride = fs->max_width / n;
+    CHECK(n <= fs->max_width);
+    CHECK(is_power_of_two(n));
+    if (inverse) {
+        fr_t inv_len;
+        fr_from_uint64(&inv_len, n);
+        blst_fr_eucl_inverse(&inv_len, &inv_len);
+        fft_g1_fast(out, in, 1, fs->reverse_roots_of_unity, stride, n);
+        for (uint64_t i = 0; i < n; i++) {
+            g1_mul(&out[i], &out[i], &inv_len);
+        }
+    } else {
+        fft_g1_fast(out, in, 1, fs->expanded_roots_of_unity, stride, n);
+    }
+    return C_KZG_OK;
+}
+
+// copied from c_kzg_4844.c
+static C_KZG_RET expand_root_of_unity(
+    fr_t *out, const fr_t *root, uint64_t width
+) {
+    out[0] = FR_ONE;
+    out[1] = *root;
+
+    for (uint64_t i = 2; !fr_is_one(&out[i - 1]); i++) {
+        CHECK(i <= width);
+        blst_fr_mul(&out[i], &out[i - 1], root);
+    }
+    CHECK(fr_is_one(&out[width]));
+
+    return C_KZG_OK;
+}
+
 static void get_rand_bytes32(Bytes32 *out) {
     static uint64_t seed = 0;
     blst_sha256(out->bytes, (uint8_t *)&seed, sizeof(seed));
-- 
2.39.2

